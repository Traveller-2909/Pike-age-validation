---
title: "Analysis_data-cleanup"
author: "TR"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, include=FALSE}
library(lubridate)
library(tidyverse)
library(ggplot2)
library(ggpubr)
library(grid)
library(ggpmisc)
```

**This MD file largely consists of code that has been written and concatenated over longer time spans and may include deprecated functions, dirty workarounds, hacks and terribly laborious solutions to easy problems. I did my best to annotate it so people can understand it and shake their heads over my inadequacy ;), but in case you have questions on particularly sketchy sections, don´t hesitate to ask!**

```{r Environmental data cleanup, include=FALSE, eval=FALSE}
rm(list = ls())

# Load Environmental data
Lungdata <- read.delim2("Raw_data/LUNG_Temp_Rügensche_Bodden_1970-2018.txt", 
                      header = T, stringsAsFactors = F)
# Load d18O time series
Pike_d18O_pred <- read.delim("Raw_data/d18O_values_Kloster.txt",
                             header = T, stringsAsFactors = F)

# Filter for temperature and salinity
Lungdata_T_S <- Lungdata%>%
  filter(Param_kurz == "W-T"|Parameter=="Wassertemperatur"|Param_kurz == "SAL"|Parameter == "Salzgehalt")

# Clean up weird data points (e.g., empty or switched data)
Lungdata_T_S <- Lungdata_T_S[-27005,]
Lungdata_T_S <- Lungdata_T_S[-27004,]

# Transform to wide (note: spread() is deprecated, use pivot_wider() instead if you want to test this chunk)
Lungdata_T_S <- spread(Lungdata_T_S, Parameter, WERT_berechnet)
Lungdata_T_S$Salzgehalt <- as.numeric(Lungdata_T_S$Salzgehalt)
Lungdata_T_S$Wassertemperatur <- as.numeric(Lungdata_T_S$Wassertemperatur)

# Make into data frame with sensible column headers
Lungdata_T_S_clean <- Lungdata_T_S%>%
  group_by(DATUM_Uhrzeit, TIEFE)%>%
  mutate(temperature = mean(Wassertemperatur, na.rm = T),
         salinity = mean(Salzgehalt, na.rm = T))%>%
  ungroup()%>%
  transmute(mstnr = MstNr,
            station = substr(Messstelle,1,3),
            year = Jahr,
            day = Tag,
            month = Monat,
            temperature =temperature,
            salinity = salinity,
            unit = Einheit,
            depth = TIEFE,
            Lat = HW_GEO,
            Long = RW_GEO,
            turbidity = SICHTTIEFE)%>%
  distinct()

# correct for shift in columns
Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$turbidity <- Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$Long
Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$Long <- Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$Lat
Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$Lat <- Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$depth
Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$depth <- Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$unit
Lungdata_T_S_clean[grepl("DB", Lungdata_T_S_clean$station),]$unit <- paste("°C")

# Correct false coordinates for measuring buoy GB1
Lungdata_T_S_clean[grepl("GB1", Lungdata_T_S_clean$station),]$Lat <- "54.18833"
Lungdata_T_S_clean[grepl("GB1", Lungdata_T_S_clean$station),]$Long <- "13.775"

str(Lungdata_T_S_clean)

Lungdata_T_S_clean$depth <- as.numeric(Lungdata_T_S_clean$depth)
Lungdata_T_S_clean$turbidity <- as.numeric(Lungdata_T_S_clean$turbidity)
Lungdata_T_S_clean$Lat <- as.numeric(Lungdata_T_S_clean$Lat)
Lungdata_T_S_clean$Long <- as.numeric(Lungdata_T_S_clean$Long)

#Form monthly means
Lungdata_T_S_month <- Lungdata_T_S_clean%>%
  group_by(station, year, month, depth)%>%
  summarise(year = year,
            temperature = mean(temperature),
            salinity = mean(salinity),
            depth = factor(ifelse(depth > 1.5, 0, 1), levels = c(0,1), 
                           labels = c("bottom", "surface")),
            Lat = first(Lat),
            Long = first(Long),
            turbidity = mean(turbidity))%>%
  ungroup()%>%
  distinct()

#Turbidity unnecessary, remove
Lungdata_T_S_month2 <- Lungdata_T_S_month%>%
  group_by(station, year, month, depth)%>%
  summarise(temperature = mean(temperature),
            salinity = mean(salinity),
            Lat = first(Lat),
            Long = first(Long))%>%
  distinct()%>%
  ungroup()

# Make single data frames for study lagoons (filter based on known geographical extent of the measuring buoys covering a given area)
Months_WRB <- Lungdata_T_S_month2%>%
  filter(Lat >= 54.40167 & Lat <= 54.62333)%>%
  filter(Long > 13.05 & Long < 13.17833)%>%
  filter(year >= 2020-15)%>%
  group_by(station, month, depth)%>%
  summarise(temperature = median(temperature),
            salinity = median(salinity),
            Lat = Lat,
            Long = Long,
            depth = depth,
            area = "WRB")%>%
  distinct()

Months_NRB <- Lungdata_T_S_month2%>%
  filter(Lat >= 54.50667 & Lat <= 54.56333)%>%
  filter(Long >= 13.17833 & Long <= 13.49)%>%
  filter(year >= 2020-15)%>%
  group_by(station, month, depth)%>%
  group_by(station, month, depth)%>%
  summarise(temperature = median(temperature),
            salinity = median(salinity),
            Lat = Lat,
            Long = Long,
            depth = depth,
            area = "WRB")%>%
  distinct()

Months_GB <- Lungdata_T_S_month2%>%
  filter(Lat >= 54.15 & Lat <= 54.26667)%>%
  filter(Long >= 13.48333  & Long <= 13.775 )%>%
  filter(year >= 2020-15)%>%
  group_by(station, month, depth)%>%
  summarise(temperature = median(temperature),
            salinity = median(salinity),
            Lat = Lat,
            Long = Long,
            depth = depth,
            area = "WRB")%>%
  distinct()

# Data frame of average monthly temperature & salinity of WRB lagoon chain (where timeseries of d18O was recorded)
WRB_average <- Months_WRB%>%
  ungroup()%>%
  group_by(month)%>%
  summarise(temperature = mean(temperature),
            salinity = mean(salinity))

#Combine into one data frame covering only the study area
Months_areas <- rbind(Months_GB, Months_NRB, Months_WRB)

# Rename column of d18O timeseries dataframe
Pike_d18O_pred <- Pike_d18O_pred%>%
  transmute(date = Sampling.date,
            salinity = Salinity,
            temperature = Water.temp,
            d18O = d18O..permil.,
            Lat = Lat,
            Long = Long)

# Convert date format to month
Pike_d18O_pred$month <- lubridate::month(parse_date_time(Pike_d18O_pred$date, orders = c("dmy")))
Pike_d18O_pred$date <- lubridate::as_date(parse_date_time(Pike_d18O_pred$date, orders = c("dmy")))

# Join with open lagoon monthly means
Pike_d18O_pred <- Pike_d18O_pred %>% inner_join(WRB_average, by = "month")

# Insert temperature measurements into equation 2 (Geffen et al.) to generate predicted d18O values for otolith aragonite
# Calculate alpha for open lagoon & harbor temperatures
Pike_d18O_pred$alpha1 = exp((15.99*1000*((Pike_d18O_pred$temperature.x+273.15)^-1)-24.25)/1000)
Pike_d18O_pred$alpha2 = exp((15.99*1000*((Pike_d18O_pred$temperature.y+273.15)^-1)-24.25)/1000)

# Predict d18O for open lagoon and harbor temperatures
Pike_d18O_pred$d18O_Oto_1 = 0.97001*(Pike_d18O_pred$alpha1*(1000+Pike_d18O_pred$d18O)-1000)-29.99
Pike_d18O_pred$d18O_Oto_2 = 0.97001*(Pike_d18O_pred$alpha2*(1000+Pike_d18O_pred$d18O)-1000)-29.99

# Insert temperature measurements into equation 1 (Patterson et al.) to generate predicted d18O values for otolith aragonite
# Calculate alpha for open lagoon & harbor temperatures
Pike_d18O_pred$alpha3 = exp((18.56*1000*((Pike_d18O_pred$temperature.x+273.15)^-1)-33.49)/1000)
Pike_d18O_pred$alpha4 = exp((18.56*1000*((Pike_d18O_pred$temperature.y+273.15)^-1)-33.49)/1000)

# Predict d18O for open lagoon and harbor temperatures
Pike_d18O_pred$d18O_Oto_3 = 0.97001*(Pike_d18O_pred$alpha3*(1000+Pike_d18O_pred$d18O)-1000)-29.99
Pike_d18O_pred$d18O_Oto_4 = 0.97001*(Pike_d18O_pred$alpha4*(1000+Pike_d18O_pred$d18O)-1000)-29.99

# Write into clean dataframe
Aragonite_prediction <- Pike_d18O_pred%>%
  transmute(month = month,
            date = date,
            salinity_shore = salinity.x,
            temperature_shore = temperature.x,
            salinity_open = salinity.y,
            temperature_open = temperature.y,
            d18O_station = d18O,
            Prediction_Geffen_station_VPDB = d18O_Oto_1,
            Prediction_Patterson_station_VPDB = d18O_Oto_3,
            Prediction_Geffen_WRB_VPDB = d18O_Oto_2,
            Prediction_Patterson_WRB_VPDB = d18O_Oto_4,
            Lat_station = Lat,
            Long_station = Long)%>%
  drop_na()

# Write data files for main analysis
write.table(Months_areas, "Data/Mean-TS_lagoons.txt", row.names = F, 
            sep = "\t", dec = ".")
write.table(Months_GB, "Data/Mean-TS_GB.txt", row.names = F, sep = "\t", dec = ".")
write.table(Months_NRB, "Data/Mean-TS_NRB.txt", row.names = F, sep = "\t", dec = ".")
write.table(Months_WRB, "Data/Mean-TS_WRB.txt", row.names = F, sep = "\t", dec = ".")
write.table(Aragonite_prediction, "Data/Predicted_otolith_d18O.txt", row.names = F,
            sep = "\t", dec = ".")
```

```{r otolith d18O plots, include=FALSE, eval=FALSE}
rm(list = ls())

# Load pike otolith d18O data
Oto_profiles <- read.csv2("Raw_data/Otolith_data_clean_with_distance_um.CSV", 
                          header = TRUE, dec = ".", sep = ";")

# Load otolith size measurements (size.x. is length of otolith in px)
Oto_sizes <- read.csv2("Raw_data/Oto_sizes_all.csv", header = TRUE)

# convert length in px to numeric
Oto_sizes$Size.x. <- as.numeric(Oto_sizes$Size.x.)

#remove NAs
Oto_profiles <- Oto_profiles %>% drop_na()


#Test plot (mark all and execute to plot axis and individual mean line)
plot(Oto_profiles[Oto_profiles$ID == "A",]$Distance_um, Oto_profiles[Oto_profiles$ID == "A",]$d18O, main = "", 
     xlab =  "", ylab = "", xlim = c(0, max(Oto_profiles[Oto_profiles$ID == "A",]$Distance_um)), 
     col.axis = "black", cex.axis = 1.7, type = "b", col = "black", lwd = 3, fg = "black", axes = FALSE)
axis(1, pos = median(Oto_profiles[Oto_profiles$ID == "A",]$d18O), at = c(0, max(Oto_profiles[Oto_profiles$ID == "A",]$Distance_um)),
     labels = FALSE, lwd.ticks = 5, tck = 0)
axis(2, pos = 0, at = round(c(min(Oto_profiles[Oto_profiles$ID == "A",]$d18O), max(Oto_profiles[Oto_profiles$ID == "A",]$d18O)), 1))

# Loop to automate plotting all transects for all fish

IDOto <- unique(Oto_sizes$ID)

IDOto2 <- unique(Oto_profiles$ID)

for (i in 1:length(IDOto)) {
  png(paste0("Figures/Otoplots/",IDOto[i], "_SIMS_2.png"), 
      width = Oto_sizes[which(Oto_sizes$ID == IDOto[i]), "Size.x.",]+585,
      height = 0.5 * (Oto_sizes[which(Oto_sizes$ID == IDOto[i]), "Size.x.",]+687), units = "px", bg = "black",
      res = 300)
  par(xaxs = "i", mar = c(12,10,0,0), font.axis=2, font.lab=2)
  plot(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "Distance_um",], 
       Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "d18O",], main = "", 
       xlab =  "", ylab = "", xlim = c(0, max(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "Distance_um",], na.rm = T)), 
       col.axis = "white", cex.axis = 1.7, type = "l", col = "white", lwd = 10, fg = "white", cex = 2, axes = FALSE, pch = 19)
  # axis(1, pos = mean(Oto_profiles[Oto_profiles$ID == IDOto[i],]$d18O), 
  #      at = c(0, max(Oto_profiles[Oto_profiles$ID == IDOto[i],]$Distance_um)),
  #      labels = FALSE, lwd.ticks = 5, tck = 0, col = "white", lty = 1, lwd = 5)
  # axis(1, pos = mean(Oto_profiles$d18O), at = c(0, max(Oto_profiles$Distance_um)),
  #      labels = FALSE, lwd.ticks = 5, tck = 0, col = "white", lty = 3, lwd = 5)
  axis(2, pos = 0, las = 2, mgp = c(0, 2, 2), cex.axis = 3, lwd = 10, col = "white", col.axis = "white",
       at = seq(round(min(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "d18O",], na.rm = T),0),
                round(max(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "d18O",], na.rm = T),0),1),
       labels = seq(round(min(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "d18O",], na.rm = T),0),
                round(max(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "d18O",], na.rm = T),0),1))
  axis(1, pos = -7.8, las = 2, mgp = c(0, 2, 2), cex.axis = 3, lwd = 10, col = "white", col.axis = "white",
       at = seq(0,round(max(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "Distance_um",], na.rm = T),0)+500,500),
       labels = seq(0, round(max(Oto_profiles[which(Oto_profiles$ID == IDOto[i]), "Distance_um",], na.rm = T),0)+500,500))
  title(main = "", ylab = expression(bold("\u03B4"^18*"O"~"Otolith"~("VPDB"))),
        cex.lab = 3.5, col.lab = "white", line = 5, font=2)
  title(xlab = expression(bold("Distance from core"~("\u03bc"~"m"))),
        cex.lab = 3.5, col.lab = "white", line = 11, font=2)
  dev.off()  
}
```

```{r automated peak detection algorithm, include=FALSE, eval=FALSE}
rm(list = ls())

# Load tributary pike otolith profiles (without core area)
Otocore_profiles_ana <- read.csv2("Raw_data/Otolith_data_anadromous_clean_core_with_distance_um.CSV", 
                                  header = T, stringsAsFactors = F, sep = ";")
Otocore_profiles_ana <- Otocore_profiles_ana %>% 
  transmute(ID = ID,
            ID2 = ID2,
            d18O = d18O,
            Distance_um = Distance_um)%>%
  drop_na()

# Load lagoon pike otolith profiles (without core area)
Otocore_profiles <- read.csv2("Raw_data/Otolith_data_clean_core_with_distance_um.CSV",header = T, stringsAsFactors = F, sep = ";")

Otocore_profiles <- Otocore_profiles %>%
  transmute(ID = ID,
            ID2 = ID2,
            d18O = d18O,
            Distance_um = Distance_um)

# Join profiles together, remove missing values and convert data to numeric
Otocore_profiles <- rbind(Otocore_profiles, Otocore_profiles_ana)
Otocore_profiles <- Otocore_profiles %>% drop_na()
Otocore_profiles$d18O <- as.numeric(Otocore_profiles$d18O)
Otocore_profiles$Distance_um <- as.numeric(Otocore_profiles$Distance_um)

# Cleanup
Otocore_profiles <- Otocore_profiles %>%
  transmute(ID = ID,
            ID2 = ID2,
            d18O = d18O,
            Distance_um = round(Distance_um,1))%>%
  group_by(ID) %>%
  arrange(ID, Distance_um)

# ID list for looping
IDOto <- unique(Otocore_profiles$ID)
Data <- data.frame(IDS = character(), BH = character(), Ages = integer())

#ggpmisc seems to only accept data frames (no tibbles allowed)
Otocore_profiles <- as.data.frame(Otocore_profiles)

for (i in 1:length(IDOto)) {
  
  V <- rle(Otocore_profiles[which(Otocore_profiles$ID == IDOto[i]), "d18O"])$values
  A <- length(V[ggpmisc:::find_peaks(V, ignore_threshold = 0.5, 
                                     span = ifelse(length(V[ggpmisc:::find_peaks(V, ignore_threshold = 0.5, span = 5)])>=10, 5, 5))])
  Data[i,"IDS"] <- IDOto[i]
  Data[i, "BH"] <- Otocore_profiles[Otocore_profiles$ID == IDOto[i],][[2,2]]
  Data[i,"Ages"] <- A
}

# Plot peak finding solution
ggplot(Otocore_profiles[Otocore_profiles$ID == "12",], aes(Distance_um, d18O)) + 
  geom_line() + stat_peaks(col = "red", ignore_threshold = 0.5, span = 5) + stat_valleys(col = "green")

# Write table
write.table(Data, "Data/Automated_count.txt", sep = "\t", dec = ".", row.names = F)
```

